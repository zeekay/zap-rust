---
title: Serialization
description: Reading and writing ZAP messages in Rust
---

# Serialization

ZAP messages are built with `MessageBuilder` and read with `MessageReader`. The format enables zero-copy access to data.

## Message Building

### Create a Message

```rust
use capnp::message::Builder;

// Default allocator (heap)
let mut message = Builder::new_default();

// Initialize root struct
let root = message.init_root::<my_struct::Builder>();
```

### Allocator Options

```rust
use capnp::message::{Builder, HeapAllocator};

// Custom allocator settings
let allocator = HeapAllocator::new()
    .first_segment_words(1024)
    .allocation_strategy(capnp::message::AllocationStrategy::FixedSize);

let mut message = Builder::new(allocator);
```

### Stack Allocation

For no_std or performance-critical paths:

```rust
use capnp::message::{Builder, SingleSegmentAllocator};

let mut buffer = [capnp::Word::NULL; 256];
let allocator = SingleSegmentAllocator::new(&mut buffer);
let mut message = Builder::new(allocator);
```

## Writing Messages

### Standard Format

```rust
use capnp::serialize;
use std::io::Write;

let mut output = Vec::new();
serialize::write_message(&mut output, &message)?;
```

### Packed Format

Smaller wire size with simple compression:

```rust
use capnp::serialize_packed;

let mut output = Vec::new();
serialize_packed::write_message(&mut output, &message)?;
```

### To File

```rust
use std::fs::File;
use capnp::serialize;

let mut file = File::create("data.bin")?;
serialize::write_message(&mut file, &message)?;
```

## Reading Messages

### Standard Format

```rust
use capnp::serialize;
use capnp::message::ReaderOptions;

let data: &[u8] = /* ... */;
let reader = serialize::read_message_from_flat_slice(
    &mut &data[..],
    ReaderOptions::new(),
)?;

let root = reader.get_root::<my_struct::Reader>()?;
```

### Packed Format

```rust
use capnp::serialize_packed;

let reader = serialize_packed::read_message(
    &mut std::io::stdin().lock(),
    ReaderOptions::new(),
)?;
```

### From Slice

Zero-copy from aligned buffer:

```rust
use capnp::serialize;

let words: &[capnp::Word] = /* aligned buffer */;
let reader = serialize::read_message_from_words(words, ReaderOptions::new())?;
```

## Reader Options

### Traversal Limit

Prevent denial-of-service from malicious messages:

```rust
use capnp::message::ReaderOptions;

let options = ReaderOptions::new()
    .traversal_limit_in_words(Some(64 * 1024 * 1024));

let reader = serialize::read_message(&mut input, options)?;
```

### Nesting Limit

Limit recursion depth:

```rust
let options = ReaderOptions::new()
    .nesting_limit(32);
```

### Unlimited (Trusted Input)

```rust
let options = ReaderOptions::new()
    .traversal_limit_in_words(None)
    .nesting_limit(128);
```

## Accessing Data

### Primitive Fields

```rust
let id: u32 = person.get_id();
let score: f64 = person.get_score();
let active: bool = person.get_active();
```

### Text Fields

```rust
// Returns capnp::text::Reader
let name_reader = person.get_name()?;

// Convert to &str (validates UTF-8)
let name: &str = name_reader.to_str()?;

// Or get raw bytes
let bytes: &[u8] = name_reader.as_bytes();
```

### Data Fields

```rust
// Returns &[u8]
let payload: &[u8] = message.get_payload()?;
```

### Lists

```rust
for item in list.get_items()? {
    println!("{}", item.get_value());
}

// Indexed access
let first = list.get_items()?.get(0);
let len = list.get_items()?.len();
```

### Nested Structs

```rust
let address = person.get_address()?;
let city = address.get_city()?.to_str()?;
```

## Setting Data

### Primitive Fields

```rust
person.set_id(123);
person.set_score(98.6);
person.set_active(true);
```

### Text Fields

```rust
person.set_name("Alice");

// From string
let name = String::from("Bob");
person.set_name(&name);
```

### Data Fields

```rust
person.set_payload(&[0x01, 0x02, 0x03]);
```

### Lists

```rust
// Initialize with size
let mut phones = person.init_phones(2);
phones.reborrow().get(0).set_number("555-1234");
phones.get(1).set_number("555-5678");
```

### Nested Structs

```rust
let mut address = person.init_address();
address.set_city("Boston");
address.set_zip(02134);
```

## Copying Between Messages

### Copy Struct

```rust
let source_reader: person::Reader = /* ... */;
let mut dest_builder: person::Builder = /* ... */;

dest_builder.copy_from(source_reader)?;
```

### Copy List

```rust
let source_list = source.get_items()?;
let mut dest_list = dest.init_items(source_list.len());

for (i, item) in source_list.iter().enumerate() {
    dest_list.reborrow().get(i).copy_from(item)?;
}
```

## Canonicalization

Produce deterministic output:

```rust
use capnp::message::Builder;

let mut message = Builder::new_default();
// ... populate message ...

let canonical = message.canonicalize()?;
// canonical is a Vec<capnp::Word>
```

## Memory Layout

ZAP uses a segmented memory model:

```rust
let segments: &[&[capnp::Word]] = reader.get_segments();

for (i, segment) in segments.iter().enumerate() {
    println!("Segment {}: {} words", i, segment.len());
}
```

## Zero-Copy with mmap

```rust
use memmap2::Mmap;
use std::fs::File;
use capnp::serialize;

let file = File::open("data.bin")?;
let mmap = unsafe { Mmap::map(&file)? };

// Ensure alignment
let words = capnp::Word::slice_from_bytes(&mmap)?;
let reader = serialize::read_message_from_words(words, ReaderOptions::new())?;

// Data is accessed directly from the memory-mapped file
```
