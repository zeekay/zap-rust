---
title: Async I/O
description: Asynchronous message reading and writing with zap-futures
---

# Async I/O

The `zap-futures` crate provides async support for reading and writing ZAP messages using the Rust async ecosystem.

## Dependencies

```toml
[dependencies]
zap = "0.25"
zap-futures = "0.25"
tokio = { version = "1", features = ["rt-multi-thread", "io-util", "net", "fs"] }
futures = "0.3"
```

## Async Reading

### From AsyncRead

```rust
use zap_futures::serialize;
use zap::message::ReaderOptions;
use tokio::io::AsyncRead;

async fn read_message<R: AsyncRead + Unpin>(
    reader: &mut R,
) -> zap::Result<zap::message::Reader<zap::serialize::OwnedSegments>> {
    serialize::read_message(reader, ReaderOptions::new()).await
}
```

### From TcpStream

```rust
use tokio::net::TcpStream;
use zap_futures::serialize;

async fn read_from_socket(stream: &mut TcpStream) -> zap::Result<()> {
    let message = serialize::read_message(stream, Default::default()).await?;
    let root = message.get_root::<my_struct::Reader>()?;
    println!("Received: {}", root.get_name()?.to_str()?);
    Ok(())
}
```

### From File

```rust
use tokio::fs::File;
use tokio::io::BufReader;
use zap_futures::serialize;

async fn read_from_file(path: &str) -> zap::Result<()> {
    let file = File::open(path).await?;
    let mut reader = BufReader::new(file);
    let message = serialize::read_message(&mut reader, Default::default()).await?;
    Ok(())
}
```

## Async Writing

### To AsyncWrite

```rust
use zap_futures::serialize;
use tokio::io::AsyncWrite;

async fn write_message<W: AsyncWrite + Unpin>(
    writer: &mut W,
    message: &zap::message::Builder<impl zap::message::Allocator>,
) -> zap::Result<()> {
    serialize::write_message(writer, message).await
}
```

### To TcpStream

```rust
use tokio::net::TcpStream;
use zap_futures::serialize;

async fn send_message(stream: &mut TcpStream, name: &str) -> zap::Result<()> {
    let mut message = zap::message::Builder::new_default();
    let mut root = message.init_root::<my_struct::Builder>();
    root.set_name(name);

    serialize::write_message(stream, &message).await
}
```

## Message Streams

Process a stream of messages:

```rust
use zap_futures::serialize::read_message;
use tokio::io::AsyncRead;

async fn process_messages<R: AsyncRead + Unpin>(
    mut reader: R,
) -> zap::Result<()> {
    loop {
        match read_message(&mut reader, Default::default()).await {
            Ok(message) => {
                let root = message.get_root::<my_struct::Reader>()?;
                process(root)?;
            }
            Err(e) if e.kind == zap::ErrorKind::PrematureEndOfFile => {
                break; // Clean EOF
            }
            Err(e) => return Err(e),
        }
    }
    Ok(())
}
```

## Tokio Integration

### Using tokio-util Compat

ZAP uses `futures::io` traits. Convert tokio types:

```rust
use tokio_util::compat::{TokioAsyncReadCompatExt, TokioAsyncWriteCompatExt};
use futures::AsyncReadExt;

async fn handle_connection(stream: tokio::net::TcpStream) -> zap::Result<()> {
    let (reader, writer) = stream.into_split();

    // Convert to futures::io types
    let reader = reader.compat();
    let writer = writer.compat_write();

    // Now use with zap_futures
    Ok(())
}
```

### LocalSet for RPC

`zap-rpc` uses `Rc` internally, requiring `LocalSet`:

```rust
use tokio::task::LocalSet;

#[tokio::main]
async fn main() {
    let local = LocalSet::new();

    local.run_until(async {
        // RPC code here
    }).await;
}
```

Or use `spawn_local`:

```rust
tokio::task::LocalSet::new()
    .run_until(async {
        let handle = tokio::task::spawn_local(async {
            // RPC task
        });
        handle.await.unwrap();
    })
    .await;
```

## async-std Integration

```toml
[dependencies]
zap-futures = "0.25"
async-std = { version = "1", features = ["attributes"] }
```

```rust
use async_std::net::TcpStream;
use zap_futures::serialize;

#[async_std::main]
async fn main() -> zap::Result<()> {
    let mut stream = TcpStream::connect("127.0.0.1:8080").await?;
    let message = serialize::read_message(&mut stream, Default::default()).await?;
    Ok(())
}
```

## Buffering

Use buffered I/O for better performance:

```rust
use futures::io::{BufReader, BufWriter};

async fn handle_connection(stream: impl AsyncRead + AsyncWrite + Unpin) {
    let (reader, writer) = stream.split();
    let reader = BufReader::new(reader);
    let writer = BufWriter::new(writer);

    // Messages are batched in the buffer
}
```

## Timeouts

```rust
use tokio::time::{timeout, Duration};

async fn read_with_timeout(stream: &mut TcpStream) -> zap::Result<()> {
    let message = timeout(
        Duration::from_secs(30),
        serialize::read_message(stream, Default::default()),
    )
    .await
    .map_err(|_| zap::Error::failed("timeout".into()))??;

    Ok(())
}
```

## Concurrent Operations

```rust
use futures::future::try_join_all;

async fn send_to_many(
    streams: Vec<&mut TcpStream>,
    message: &zap::message::Builder<impl zap::message::Allocator>,
) -> zap::Result<()> {
    let futures: Vec<_> = streams
        .into_iter()
        .map(|stream| serialize::write_message(stream, message))
        .collect();

    try_join_all(futures).await?;
    Ok(())
}
```

## Error Handling Patterns

```rust
use zap::ErrorKind;

async fn robust_read<R: AsyncRead + Unpin>(reader: &mut R) -> zap::Result<Option<Message>> {
    match serialize::read_message(reader, Default::default()).await {
        Ok(msg) => Ok(Some(msg)),
        Err(e) => match e.kind {
            ErrorKind::PrematureEndOfFile => Ok(None), // Clean close
            ErrorKind::Disconnected => Ok(None),       // Peer closed
            _ => Err(e),                               // Real error
        },
    }
}
```

## Channel-Based Messaging

```rust
use tokio::sync::mpsc;

struct MessageSender {
    tx: mpsc::Sender<Vec<u8>>,
}

impl MessageSender {
    async fn send(&self, message: &zap::message::Builder<impl zap::message::Allocator>) -> zap::Result<()> {
        let mut buf = Vec::new();
        zap::serialize::write_message(&mut buf, message)?;
        self.tx.send(buf).await.map_err(|_| {
            zap::Error::failed("channel closed".into())
        })
    }
}
```
